namespace koreandns
{
	// 1. 내림차순 경계 벗어난 위치 확인
	// 2. 자리 교체 방법은 자리 교체할 인덱스 보다 큰 값 중에서 가장 작은 값
	// 3. 오름차순 (뒤집기)
	
	// ex ) 5 3 4 2 1 의 다음 순열은?
	// 가장 뒤 인덱스부터 내려오면서 내림차순이 되는지 확인
	// 3 < 4 내림 차순이 아니므로 3의 값에 해당하는 인덱스가 변경할 위치
	// 3 보다 큰 값 중에서 가장 작은 값을 찾아야 한다. (3의 값을 만나기 전까지 인덱스 중에서 찾아야 함) 3 -> [4, 2, 1]
	// 3과 4를 교체 해주고
	// 3의 값을 만나기 전까지 인덱스를 뒤집어 준다. (오름차순으로 만들어주기) 3 2 1 -> 1 2 3
	// 결과 : 5 4 1 2 3
	
	bool next_permutation(vector<int> &arr, int n)
	{
		// 1)
		int i = n - 1;
		while (0 < i and arr[i] <= arr[i - 1])
		{
			--i;
		}

		if (0 == i)
		{
			return false;
		}

		// 2)
		int j = n-1;
		while (arr[j] <= arr[i - 1])
		{
			--j;
		}

		swap(arr[i-1], arr[j]);

		// 3)
		j = n - 1;
		while (i < j)
		{
			swap(arr[i], arr[j]);
			++i;
			--j;
		}

		return true;
	}

	// 1. 오름차순 경계 벗어난 위치 확인
	// 2. 자리 교체 방법은 자리 교체할 인덱스 보다 작은 값 중에서 가장 큰 값
	// 3. 내림차순 (뒤집기)
	
	// ex ) 5 4 3 2 1 이전 순열은 ?
	// 가장 뒤 인덱스부터 내려오면서 오름차순이 되는지 확인
	// 2 > 1 오름 차순이 아니므로 2의 값에 해당하는 인덱스가 변경할 위치
	// 2 보다 작은 값 중에서 가장 큰 값을 찾아야 한다. (2의 값을 만나기 전까지 인덱스 중에서 찾아야 함) 2 -> [1]
	// 2와 1를 교체 해주고
	// 2의 값을 만나기 전까지 인덱스를 뒤집어 준다. (오름차순으로 만들어주기) 뒤 집어줄 인덱스가 없다. 1 하나 밖에 없어서
	// 결과 : 5 4 3 1 2
	
	bool prev_permutation(vector<int> &arr, int n)
	{
		// 1)
		int i = n - 1;
		while (0 < i and arr[i - 1] < arr[i])
		{
			--i;
		}

		if (0 == i)
		{
			return false;
		}

		// 2)
		int j = n - 1;
		while (arr[i - 1] < arr[j])
		{
			--j;
		}

		swap(arr[i - 1], arr[j]);

		// 3)
		j = n - 1;
		while (i < j)
		{
			swap(arr[i], arr[j]);
			++i;
			--j;
		}

		return true;
	}
}