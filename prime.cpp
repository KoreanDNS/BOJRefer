namespace koreandns
{
	// 소수 : 약수가 1과 자기 자신 밖에 없는 수
	// N이 소수가 되려면, 2보다 크거나 같고, 루트N 보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
	// 이유 : N이 소수가 아니라면 N = a * b로 나타낼 수 있다. (a <= b)
	// b < a 라면 두 수를 바꿔서 항상 a <= b로 만들 수 있다.
	// 두 수 a와 b의 차이가 가장 작은 경우는 루트 N이다.
	// 따라서, 루트 N까지만 검사를 해보면 된다.
		
	// N = a * b (a <=b)
	// N이 소수가 아니라면 a는 b보다 작을때 a <= 루트 N , 루트 N <= b 조건이 항상 성립해야 한다.
	// 왜냐면 a < 루트 N, b < 루트 N 이라고 가정을 해 보면 a * b < N 이 나온다. 이건 말이 안 되는거다. a * b = N이 나와야 하기 때문
	// 반대로 루트 N < a , 루트 N < b 이라고 가정을 해 봐도 N < a * b 나오기 때문에 말이 안 된다. a * b = N이 나와야 하기 때문..
	// 그래서 한쪽만 검사를 해보면 되는데 a쪽이 b쪽보다 범위도 적고 빠르기 때문에 한쪽 a에서 구하는게 좋다.
	// 한쪽에서 약수가 없어야 한다. 2부터 루트 N까지 나눠 떨어지는 수가 있다면 소수가 아니다.
	// 루트N은 실수 범위이기 때문에 정수 범위 내에서 찾아주기 위해서 양변을 제곱 해주었다. 그래서 i * i <= n 라는 식이 도출이 되었다.
	
	bool prime(int n)
	{
		if (n < 2)
		{
			return false;
		}

		for (int i = 2; i * i <= n; ++i)
		{
			if (0 == n % i)
			{
				return false;
			}
		}

		return true;
	}
}